{
  "tree-sitter-typescript-tags": "(function_signature\n  name: (identifier) @name.definition.function) @definition.function\n\n(method_signature\n  name: (property_identifier) @name.definition.method) @definition.method\n\n(abstract_method_signature\n  name: (property_identifier) @name.definition.method) @definition.method\n\n(abstract_class_declaration\n  name: (type_identifier) @name.definition.class) @definition.class\n\n(module\n  name: (identifier) @name.definition.module) @definition.module\n\n(interface_declaration\n  name: (type_identifier) @name.definition.interface) @definition.interface\n\n(type_annotation\n  (type_identifier) @name.reference.type) @reference.type\n\n(new_expression\n  constructor: (identifier) @name.reference.class) @reference.class\n",
  "tree-sitter-rust-tags": "; ADT definitions\n\n(struct_item\n    name: (type_identifier) @name.definition.class) @definition.class\n\n(enum_item\n    name: (type_identifier) @name.definition.class) @definition.class\n\n(union_item\n    name: (type_identifier) @name.definition.class) @definition.class\n\n; type aliases\n\n(type_item\n    name: (type_identifier) @name.definition.class) @definition.class\n\n; method definitions\n\n(declaration_list\n    (function_item\n        name: (identifier) @name.definition.method)) @definition.method\n\n; function definitions\n\n(function_item\n    name: (identifier) @name.definition.function) @definition.function\n\n; trait definitions\n(trait_item\n    name: (type_identifier) @name.definition.interface) @definition.interface\n\n; module definitions\n(mod_item\n    name: (identifier) @name.definition.module) @definition.module\n\n; macro definitions\n\n(macro_definition\n    name: (identifier) @name.definition.macro) @definition.macro\n\n; references\n\n(call_expression\n    function: (identifier) @name.reference.call) @reference.call\n\n(call_expression\n    function: (field_expression\n        field: (field_identifier) @name.reference.call)) @reference.call\n\n(macro_invocation\n    macro: (identifier) @name.reference.call) @reference.call\n\n; implementations\n\n(impl_item\n    trait: (type_identifier) @name.reference.implementation) @reference.implementation\n\n(impl_item\n    type: (type_identifier) @name.reference.implementation\n    !trait) @reference.implementation\n",
  "tree-sitter-ruby-tags": "; Method definitions\n\n(\n  (comment)* @doc\n  .\n  [\n    (method\n      name: (_) @name.definition.method) @definition.method\n    (singleton_method\n      name: (_) @name.definition.method) @definition.method\n  ]\n  (#strip! @doc \"^#\\\\s*\")\n  (#select-adjacent! @doc @definition.method)\n)\n\n(alias\n  name: (_) @name.definition.method) @definition.method\n\n(setter\n  (identifier) @ignore)\n\n; Class definitions\n\n(\n  (comment)* @doc\n  .\n  [\n    (class\n      name: [\n        (constant) @name.definition.class\n        (scope_resolution\n          name: (_) @name.definition.class)\n      ]) @definition.class\n    (singleton_class\n      value: [\n        (constant) @name.definition.class\n        (scope_resolution\n          name: (_) @name.definition.class)\n      ]) @definition.class\n  ]\n  (#strip! @doc \"^#\\\\s*\")\n  (#select-adjacent! @doc @definition.class)\n)\n\n; Module definitions\n\n(\n  (module\n    name: [\n      (constant) @name.definition.module\n      (scope_resolution\n        name: (_) @name.definition.module)\n    ]) @definition.module\n)\n\n; Calls\n\n(call method: (identifier) @name.reference.call) @reference.call\n\n(\n  [(identifier) (constant)] @name.reference.call @reference.call\n  (#is-not? local)\n  (#not-match? @name.reference.call \"^(lambda|load|require|require_relative|__FILE__|__LINE__)$\")\n)\n",
  "tree-sitter-ql-tags": "(classlessPredicate\n  name: (predicateName) @name.definition.function) @definition.function\n\n(memberPredicate\n  name: (predicateName) @name.definition.method) @definition.method\n\n(aritylessPredicateExpr\n  name: (literalId) @name.reference.call) @reference.call\n\n(module\n  name: (moduleName) @name.definition.module) @definition.module\n\n(dataclass\n  name: (className) @name.definition.class) @definition.class\n\n(datatype\n  name: (className) @name.definition.class) @definition.class\n\n(datatypeBranch\n  name: (className) @name.definition.class) @definition.class\n\n(qualifiedRhs\n  name: (predicateName) @name.reference.call) @reference.call\n\n(typeExpr\n  name: (className) @name.reference.type) @reference.type\n",
  "tree-sitter-python-tags": "(class_definition\n  name: (identifier) @name.definition.class) @definition.class\n\n(function_definition\n  name: (identifier) @name.definition.function) @definition.function\n\n(call\n  function: [\n      (identifier) @name.reference.call\n      (attribute\n        attribute: (identifier) @name.reference.call)\n  ]) @reference.call\n",
  "tree-sitter-php-tags": "(class_declaration\n  name: (name) @name.definition.class) @definition.class\n\n(function_definition\n  name: (name) @name.definition.function) @definition.function\n\n(method_declaration\n  name: (name) @name.definition.function) @definition.function\n\n(object_creation_expression\n  [\n    (qualified_name (name) @name.reference.class)\n    (variable_name (name) @name.reference.class)\n  ]) @reference.class\n\n(function_call_expression\n  function: [\n    (qualified_name (name) @name.reference.call)\n    (variable_name (name)) @name.reference.call\n  ]) @reference.call\n\n(scoped_call_expression\n  name: (name) @name.reference.call) @reference.call\n\n(member_call_expression\n  name: (name) @name.reference.call) @reference.call\n",
  "tree-sitter-ocaml-tags": "; Modules\n;--------\n\n(\n  (comment)? @doc .\n  (module_definition (module_binding (module_name) @name.definition.module) @definition.module)\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(module_path (module_name) @name.reference.module) @reference.module\n\n; Modules types\n;--------------\n\n(\n  (comment)? @doc .\n  (module_type_definition (module_type_name) @name.definition.interface) @definition.interface\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(module_type_path (module_type_name) @name.reference.implementation) @reference.implementation\n\n; Functions\n;----------\n\n(\n  (comment)? @doc .\n  (value_definition\n    [\n      (let_binding\n        pattern: (value_name) @name.definition.function\n        (parameter))\n      (let_binding\n        pattern: (value_name) @name.definition.function\n        body: [(fun_expression) (function_expression)])\n    ] @definition.function\n  )\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(\n  (comment)? @doc .\n  (external (value_name) @name.definition.function) @definition.function\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(application_expression\n  function: (value_path (value_name) @name.reference.call)) @reference.call\n\n(infix_expression\n  left: (value_path (value_name) @name.reference.call)\n  (infix_operator) @reference.call\n  (#eq? @reference.call \"@@\"))\n\n(infix_expression\n  (infix_operator) @reference.call\n  right: (value_path (value_name) @name.reference.call)\n  (#eq? @reference.call \"|>\"))\n\n; Operator\n;---------\n\n(\n  (comment)? @doc .\n  (value_definition\n    (let_binding\n      pattern: (parenthesized_operator [\n        (prefix_operator)\n        (infix_operator)\n        (hash_operator)\n        (indexing_operator)\n        (let_operator)\n        (and_operator)\n        (match_operator)\n      ] @name.definition.function)) @definition.function)\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n[\n  (prefix_operator)\n  (sign_operator)\n  (infix_operator)\n  (hash_operator)\n  (indexing_operator)\n  (let_operator)\n  (and_operator)\n  (match_operator)\n] @name.reference.call @reference.call\n\n; Classes\n;--------\n\n(\n  (comment)? @doc .\n  [\n    (class_definition (class_binding (class_name) @name.definition.class) @definition.class)\n    (class_type_definition (class_type_binding (class_type_name) @name.definition.class) @definition.class)\n  ]\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n[\n  (class_path (class_name) @name.reference.class)\n  (class_type_path (class_type_name) @name.reference.class)\n] @reference.class\n\n; Methods\n;--------\n\n(\n  (comment)? @doc .\n  (method_definition (method_name) @name.definition.method) @definition.method\n  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n)\n\n(method_invocation (method_name) @name.reference.call) @reference.call\n",
  "tree-sitter-javascript-tags": "(\n  (comment)* @doc\n  .\n  (method_definition\n    name: (property_identifier) @name.definition.method) @definition.method\n  (#not-eq? @name.definition.method \"constructor\")\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.method)\n)\n\n(\n  (comment)* @doc\n  .\n  [\n    (class\n      name: (_) @name.definition.class)\n    (class_declaration\n      name: (_) @name.definition.class)\n  ] @definition.class\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.class)\n)\n\n(\n  (comment)* @doc\n  .\n  [\n    (function\n      name: (identifier) @name.definition.function)\n    (function_declaration\n      name: (identifier) @name.definition.function)\n    (generator_function\n      name: (identifier) @name.definition.function)\n    (generator_function_declaration\n      name: (identifier) @name.definition.function)\n  ] @definition.function\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.function)\n)\n\n(\n  (comment)* @doc\n  .\n  (lexical_declaration\n    (variable_declarator\n      name: (identifier) @name.definition.function\n      value: [(arrow_function) (function)]) @definition.function)\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.function)\n)\n\n(\n  (comment)* @doc\n  .\n  (variable_declaration\n    (variable_declarator\n      name: (identifier) @name.definition.function\n      value: [(arrow_function) (function)]) @definition.function)\n  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n  (#select-adjacent! @doc @definition.function)\n)\n\n(assignment_expression\n  left: [\n    (identifier) @name.definition.function\n    (member_expression\n      property: (property_identifier) @name.definition.function)\n  ]\n  right: [(arrow_function) (function)]\n) @definition.function\n\n(pair\n  key: (property_identifier) @name.definition.function\n  value: [(arrow_function) (function)]) @definition.function\n\n(\n  (call_expression\n    function: (identifier) @name.reference.call) @reference.call\n  (#not-match? @name.reference.call \"^(require)$\")\n)\n\n(call_expression\n  function: (member_expression\n    property: (property_identifier) @name.reference.call)\n  arguments: (_) @reference.call)\n\n(new_expression\n  constructor: (_) @name.reference.class) @reference.class\n",
  "tree-sitter-java-tags": "(class_declaration\n  name: (identifier) @name.definition.class) @definition.class\n\n(method_declaration\n  name: (identifier) @name.definition.method) @definition.method\n\n(method_invocation\n  name: (identifier) @name.reference.call\n  arguments: (argument_list) @reference.call)\n\n(interface_declaration\n  name: (identifier) @name.definition.interface) @definition.interface\n\n(type_list\n  (type_identifier) @name.reference.implementation) @reference.implementation\n\n(object_creation_expression\n  type: (type_identifier) @name.reference.class) @reference.class\n\n(superclass (type_identifier) @name.reference.class) @reference.class\n",
  "tree-sitter-go-tags": "(\n  (comment)* @doc\n  .\n  (function_declaration\n    name: (identifier) @name.definition.function) @definition.function\n  (#strip! @doc \"^//\\\\s*\")\n  (#set-adjacent! @doc @definition.function)\n)\n\n(\n  (comment)* @doc\n  .\n  (method_declaration\n    name: (field_identifier) @name.definition.method) @definition.method\n  (#strip! @doc \"^//\\\\s*\")\n  (#set-adjacent! @doc @definition.method)\n)\n\n(call_expression\n  function: [\n    (identifier) @name.reference.call\n    (parenthesized_expression (identifier) @name.reference.call)\n    (selector_expression field: (field_identifier) @name.reference.call)\n    (parenthesized_expression (selector_expression field: (field_identifier) @name.reference.call))\n  ]) @reference.call\n\n(type_spec\n  name: (type_identifier) @name.definition.type) @definition.type\n\n(type_identifier) @name.reference.type @reference.type\n",
  "tree-sitter-elm-tags": "(value_declaration (function_declaration_left (lower_case_identifier) @name.definition.function)) @definition.function\n\n(function_call_expr (value_expr (value_qid) @name.reference.function)) @reference.function\n(exposed_value (lower_case_identifier) @name.reference.function)) @reference.function\n(type_annotation ((lower_case_identifier) @name.reference.function) (colon)) @reference.function\n\n(type_declaration ((upper_case_identifier) @name.definition.type) ) @definition.type\n\n(type_ref (upper_case_qid (upper_case_identifier) @name.reference.type)) @reference.type\n(exposed_type (upper_case_identifier) @name.reference.type)) @reference.type\n\n(type_declaration (union_variant (upper_case_identifier) @name.definition.union)) @definition.union\n\n(value_expr (upper_case_qid (upper_case_identifier) @name.reference.union)) @reference.union\n\n\n(module_declaration \n    (upper_case_qid (upper_case_identifier)) @name.definition.module\n) @definition.module\n",
  "tree-sitter-elixir-tags": "; Definitions\n\n; * modules and protocols\n(call\n  target: (identifier) @ignore\n  (arguments (alias) @name.definition.module)\n  (#match? @ignore \"^(defmodule|defprotocol)$\")) @definition.module\n\n; * functions/macros\n(call\n  target: (identifier) @ignore\n  (arguments\n    [\n      ; zero-arity functions with no parentheses\n      (identifier) @name.definition.function\n      ; regular function clause\n      (call target: (identifier) @name.definition.function)\n      ; function clause with a guard clause\n      (binary_operator\n        left: (call target: (identifier) @name.definition.function)\n        operator: \"when\")\n    ])\n  (#match? @ignore \"^(def|defp|defdelegate|defguard|defguardp|defmacro|defmacrop|defn|defnp)$\")) @definition.function\n\n; References\n\n; ignore calls to kernel/special-forms keywords\n(call\n  target: (identifier) @ignore\n  (#match? @ignore \"^(def|defp|defdelegate|defguard|defguardp|defmacro|defmacrop|defn|defnp|defmodule|defprotocol|defimpl|defstruct|defexception|defoverridable|alias|case|cond|else|for|if|import|quote|raise|receive|require|reraise|super|throw|try|unless|unquote|unquote_splicing|use|with)$\"))\n\n; ignore module attributes\n(unary_operator\n  operator: \"@\"\n  operand: (call\n    target: (identifier) @ignore))\n\n; * function call\n(call\n  target: [\n   ; local\n   (identifier) @name.reference.call\n   ; remote\n   (dot\n     right: (identifier) @name.reference.call)\n  ]) @reference.call\n\n; * pipe into function call\n(binary_operator\n  operator: \"|>\"\n  right: (identifier) @name.reference.call) @reference.call\n\n; * modules\n(alias) @name.reference.module @reference.module\n",
  "tree-sitter-elisp-tags": ";; defun/defsubst\n(function_definition name: (symbol) @name.definition.function) @definition.function\n\n;; Treat macros as function definitions for the sake of TAGS.\n(macro_definition name: (symbol) @name.definition.function) @definition.function\n\n;; Match function calls\n(list (symbol) @name.reference.function) @reference.function\n",
  "tree-sitter-cpp-tags": "(struct_specifier name: (type_identifier) @name.definition.class body:(_)) @definition.class\n\n(declaration type: (union_specifier name: (type_identifier) @name.definition.class)) @definition.class\n\n(function_declarator declarator: (identifier) @name.definition.function) @definition.function\n\n(function_declarator declarator: (field_identifier) @name.definition.function) @definition.function\n\n(function_declarator declarator: (qualified_identifier scope: (namespace_identifier) @scope name: (identifier) @name.definition.method)) @definition.method\n\n(type_definition declarator: (type_identifier) @name.definition.type) @definition.type\n\n(enum_specifier name: (type_identifier) @name.definition.type) @definition.type\n\n(class_specifier name: (type_identifier) @name.definition.class) @definition.class\n",
  "tree-sitter-c_sharp-tags": "(class_declaration\n name: (identifier) @name.definition.class\n ) @definition.class\n\n(class_declaration\n   bases: (base_list (_) @name.reference.class)\n ) @reference.class\n\n(interface_declaration\n name: (identifier) @name.definition.interface\n ) @definition.interface\n\n(interface_declaration\n bases: (base_list (_) @name.reference.interface)\n ) @reference.interface\n\n(method_declaration\n name: (identifier) @name.definition.method\n ) @definition.method\n\n(object_creation_expression\n type: (identifier) @name.reference.class\n ) @reference.class\n\n(type_parameter_constraints_clause\n target: (identifier) @name.reference.class\n ) @reference.class\n\n(type_constraint\n type: (identifier) @name.reference.class\n ) @reference.class\n\n(variable_declaration\n type: (identifier) @name.reference.class\n ) @reference.class\n\n(invocation_expression\n function:\n  (member_access_expression\n    name: (identifier) @name.reference.send\n )\n) @reference.send\n\n(namespace_declaration\n name: (identifier) @name.definition.module\n) @definition.module\n",
  "tree-sitter-c-tags": "(struct_specifier name: (type_identifier) @name.definition.class body:(_)) @definition.class\n\n(declaration type: (union_specifier name: (type_identifier) @name.definition.class)) @definition.class\n\n(function_declarator declarator: (identifier) @name.definition.function) @definition.function\n\n(type_definition declarator: (type_identifier) @name.definition.type) @definition.type\n\n(enum_specifier name: (type_identifier) @name.definition.type) @definition.type\n"
}